# `scene_data.py` 모듈 상세 분석 보고서

이 문서는 `backend/core/scene_data.py` 모듈의 역할, 주요 로직, 그리고 각 함수/메서드의 입출력 및 그 목적에 대해 상세히 분석합니다.

## 모듈의 핵심 역할

`scene_data.py` 모듈은 렌더링될 씬(Scene)에 포함된 모든 가우시안 객체들을 효율적으로 관리하기 위한 데이터 구조인 **`SceneData` 클래스**를 제공합니다. 기존의 `List[Gaussian2D]` 방식이 가우시안 객체를 하나씩 생성하고 리스트에 추가하면서 발생하는 오버헤드로 인해 성능 저하를 유발하는 문제를 해결하기 위해 도입되었습니다.

이 모듈의 핵심 아이디어는 **객체 생성 지양 및 NumPy 배열을 이용한 일괄 처리(Batch Processing)**입니다. 즉, 개별 `Gaussian2D` 객체 리스트 대신, 여러 가우시안의 속성(위치, 회전, 크기 등)을 각각의 거대한 NumPy 배열로 묶어서 관리합니다. 이를 통해 수백, 수천 개의 가우시안 데이터를 추가, 삭제, 수정할 때 Python 객체 생성/소멸에 드는 비용을 없애고, NumPy가 제공하는 C 레벨의 빠른 연산 속도를 최대한 활용하여 성능을 40배에서 80배까지 향상시킵니다.

---

## `SceneData` 클래스 분석

### 1. 클래스 역할

씬에 존재하는 모든 2D 가우시안 스플랫 데이터를 NumPy 배열 형태로 저장하고 관리하는 컨테이너 클래스입니다. 모든 가우시안의 `position`은 `positions` 배열에, `rotation`은 `rotations` 배열에 저장되는 '구조체 배열(Array of Structures)'과 유사한 패턴을 따릅니다.

### 2. 주요 속성 (Attributes)

`__init__` 메서드에서 초기화됩니다.

*   `positions`: `np.ndarray (K, 3)` - K개 가우시안의 모든 x, y, z 위치.
*   `rotations`: `np.ndarray (K, 4)` - K개 가우시안의 모든 회전 쿼터니언.
*   `scales`: `np.ndarray (K, 3)` - K개 가우시안의 모든 3축 크기.
*   `colors`: `np.ndarray (K, 3)` - K개 가우시안의 모든 RGB 색상.
*   `opacities`: `np.ndarray (K,)` - K개 가우시안의 모든 불투명도.
*   `count`: `int` - 현재 씬에 저장된 총 가우시안의 개수.

### 3. 주요 메서드 (Methods) 분석

#### `add_gaussians_batch(self, ...)`
*   **역할**: 여러 개의 가우시안 데이터를 NumPy 배열 형태로 한 번에 추가합니다. 이 클래스의 가장 핵심적이고 효율적인 데이터 추가 방식입니다.
*   **입력**: `positions`, `rotations`, `scales`, `colors`, `opacities`에 해당하는 NumPy 배열들. 입력 배열은 (N, M, 3) 같은 다차원 형태일 수 있으나, 내부적으로 `-1`을 이용해 1차원 리스트 형태의 (K, ...)로 평탄화하여 처리합니다.
*   **로직 분석**:
    1.  **로직**: `reshape(-1, ...)`를 사용하여 입력된 다차원 배열들을 가우시안 목록을 나타내는 2D 배열 (K, 속성차원) 또는 1D 배열 (K,)로 변환합니다.
    2.  **이유**: 브러시 스트로크처럼 여러 점으로 구성된 다차원 배열을 개별 가우시안 데이터 목록으로 쉽게 변환하기 위함입니다.
    3.  **로직**: 씬이 비어있으면(`self.count == 0`) 입력받은 배열을 그대로 할당하고, 그렇지 않으면 `np.vstack` (수직 쌓기) 이나 `np.concatenate` (연결)를 사용해 기존 배열의 끝에 새로운 데이터를 이어 붙입니다.
    4.  **이유**: `list.append`처럼 객체를 하나씩 추가하는 대신, 메모리상에 연속된 배열들을 한 번의 연산으로 합치므로 극도로 빠릅니다.

#### `extend(self, gaussians: List)`
*   **역할**: 구버전과의 호환성을 위해 `Gaussian2D` 객체의 리스트를 입력받아 `SceneData`에 추가합니다.
*   **입력**: `List[Gaussian2D]` 객체.
*   **로직 분석**:
    *   **로직**: 입력받은 `gaussians` 리스트를 순회하며 각 객체의 `position`, `rotation` 등의 속성을 추출하여 각각 별도의 NumPy 배열로 변환합니다. 그 후, 이 배열들을 `add_gaussians_batch` 메서드에 전달하여 데이터를 추가합니다.
    *   **경고**: 이 메서드는 내부적으로 Python 리스트 순회와 객체 속성 접근이 발생하므로, `add_gaussians_batch`를 직접 사용하는 것보다 훨씬 느립니다. 호환성 유지를 위한 기능일 뿐, 성능이 중요한 곳에서는 사용을 지양해야 합니다.

#### `to_gaussian_list(self)`
*   **역할**: 현재 `SceneData`가 가진 NumPy 배열 데이터를 다시 `List[Gaussian2D]` 객체 형태로 변환하여 반환합니다.
*   **출력**: `List[Gaussian2D]` 객체.
*   **로직 분석**:
    *   **로직**: `self.count` 만큼 반복문을 실행하면서, `i`번째 인덱스에 해당하는 `positions[i]`, `rotations[i]` 등의 데이터를 사용하여 새로운 `Gaussian2D` 객체를 생성하고 리스트에 담아 반환합니다.
    *   **경고**: 이 메서드는 `SceneData`의 설계 목적(탈객체화)에 정면으로 위배되며, 많은 수의 Python 객체를 생성하므로 매우 느립니다. `Gaussian2D` 객체 구조를 반드시 필요로 하는 레거시 코드와의 연동을 위해서만 제한적으로 사용해야 합니다.

#### `__delitem__(self, key)`
*   **역할**: 인덱스 또는 슬라이스(slice)를 사용하여 씬에서 하나 이상의 가우시안을 삭제합니다.
*   **입력**: `int` 인덱스 또는 `slice` 객체.
*   **로직 분석**:
    *   **슬라이스 삭제 (`del scene[5:10]`)**:
        *   **로직**: 삭제할 영역을 제외한 나머지 부분들을 선택하여 새로운 배열을 만듭니다. 예를 들어, `[:start]` 부분과 `[stop:]` 부분을 `np.vstack` 이나 `np.concatenate`로 합칩니다.
        *   **이유**: 유지할 데이터만 복사하여 새 배열을 만드는 것이 특정 부분을 삭제하는 것보다 NumPy에서 더 효율적입니다. `.copy()`를 호출하여 원본 데이터에 대한 뷰(view)가 아닌 독립적인 배열을 보장합니다.
    *   **단일 인덱스 삭제 (`del scene[5]`)**:
        *   **로직**: 삭제할 인덱스를 `False`로, 나머지를 `True`로 하는 불리언 마스크(boolean mask) 배열을 생성합니다. 이 마스크를 사용하여 `True`에 해당하는 요소만 선택하여 새 배열을 만듭니다.
        *   **이유**: 불리언 인덱싱은 NumPy에서 특정 조건에 맞는 데이터만 효율적으로 필터링하는 표준적인 방법입니다.

#### 기타 메서드
*   `clear()`: 모든 가우시안 데이터를 삭제하고 씬을 초기 상태로 되돌립니다. 내부적으로 `__init__`을 다시 호출합니다.
*   `__len__()`: `len(scene)` 호출 시, 저장된 총 가우시안의 수(`self.count`)를 반환합니다.
*   `__repr__()`: `print(scene)` 호출 시, "SceneData(gaussians=...)" 형태로 객체 정보를 간결하게 표시합니다.
